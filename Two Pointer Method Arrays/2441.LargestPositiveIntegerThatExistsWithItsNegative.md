# ğŸš€ Problem: Return Maximum Positive Number That Also Exists as Its Negative

## ğŸ“œ Problem Statement
You're given an array of integers `arr`.  
ğŸ” Return the **maximum positive integer** `x` such that **both** `x` and `-x` exist in the array.  
If **no such number** exists, return `-1`.

---

## ğŸ§ª Examples

### âœ… Example 1:
**Input:** `[3, 1, -3, 2, -1]`  
**Output:** `3`  
**Why?** â†’ Both `3` and `-3` exist, and itâ€™s the largest such number.

### âŒ Example 2:
**Input:** `[1, 2, 4, 5]`  
**Output:** `-1`  
**Why?** â†’ No number has its negative in the array.

---

## ğŸŒ Brute Force Approach (Nested Loops)

### ğŸ”§ Logic:
Loop through every pair `(i, j)` and check if `arr[i] == -arr[j]`.  
Track the maximum absolute value seen.

### ğŸ’» Java Code:
```java
int output = -1;
for (int i = 0; i < arr.length; i++) {
    for (int j = i + 1; j < arr.length; j++) {
        if (arr[i] == -arr[j]) {
            output = Math.max(output, Math.abs(arr[i]));
        }
    }
}
System.out.println(output);

ğŸ§® Time Complexity:
O(nÂ²) â†’ Not efficient for large arrays.

âš¡ Optimized Approach Using HashSet
ğŸ§  Intuition: Remember What You've Seen
As you iterate:

Store every number in a HashSet.

For each number num, check if -num exists in the set.

If yes â†’ update max with Math.abs(num).

âœ… Benefits:
Fast lookups with HashSet.

Only one pass through the array.

Java Code (Optimized Version)

import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];

        // Input array
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        Set<Integer> set = new HashSet<>();
        int output = -1;

        for (int num : arr) {
            if (set.contains(-num)) {
                output = Math.max(output, Math.abs(num));
            }
            set.add(num);
        }

        System.out.println(output);
    }
}